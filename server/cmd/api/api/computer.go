package api

import (
	"context"
	"encoding/json"
	"fmt"
	"os/exec"
	"strconv"
	"time"

	"github.com/gorilla/websocket"
	"github.com/onkernel/kernel-images/server/lib/logger"
	oapi "github.com/onkernel/kernel-images/server/lib/oapi"
)

func (s *ApiService) MoveMouse(ctx context.Context, request oapi.MoveMouseRequestObject) (oapi.MoveMouseResponseObject, error) {
	log := logger.FromContext(ctx)

	// Validate request body
	if request.Body == nil {
		return oapi.MoveMouse400JSONResponse{BadRequestErrorJSONResponse: oapi.BadRequestErrorJSONResponse{Message: "request body is required"}}, nil
	}
	body := *request.Body

	// Ensure non-negative coordinates
	if body.X < 0 || body.Y < 0 {
		return oapi.MoveMouse400JSONResponse{BadRequestErrorJSONResponse: oapi.BadRequestErrorJSONResponse{Message: "coordinates must be non-negative"}}, nil
	}

	// Build xdotool arguments
	args := []string{}

	// Hold modifier keys (keydown)
	if body.HoldKeys != nil {
		for _, key := range *body.HoldKeys {
			args = append(args, "keydown", key)
		}
	}

	// Move the cursor to the desired coordinates
	args = append(args, "mousemove", "--sync", strconv.Itoa(body.X), strconv.Itoa(body.Y))

	// Release modifier keys (keyup)
	if body.HoldKeys != nil {
		for _, key := range *body.HoldKeys {
			args = append(args, "keyup", key)
		}
	}

	log.Info("executing xdotool", "args", args)

	output, err := defaultXdoTool.Run(ctx, args...)
	if err != nil {
		log.Error("xdotool command failed", "err", err, "output", string(output))
		return oapi.MoveMouse500JSONResponse{InternalErrorJSONResponse: oapi.InternalErrorJSONResponse{Message: "failed to move mouse"}}, nil
	}

	return oapi.MoveMouse200Response{}, nil
}

// Define interface types for our new endpoint
// These should match the structure expected by the generated code

// SetScreenResolutionParams represents query parameters for our endpoint
type SetScreenResolutionParams struct {
	Width  int
	Height int
	Rate   *int
}

// For testing
type SetScreenResolutionFunc func(ctx context.Context, req SetScreenResolutionRequestObject) (SetScreenResolutionResponseObject, error)

// This would be auto-generated by oapi-codegen, but we're defining it manually
type SetScreenResolutionRequestObject struct {
	Width  int    // Required query parameter
	Height int    // Required query parameter
	Rate   *int   // Optional query parameter
	WSURL  string // WebSocket URL (calculated in handler)
}

// Response types for different status codes
type SetScreenResolution200JSONResponse struct {
	Ok bool `json:"ok"`
}

type SetScreenResolution400JSONResponse struct {
	Message string `json:"message"`
}

type SetScreenResolution409JSONResponse struct {
	Message string `json:"message"`
}

type SetScreenResolution500JSONResponse struct {
	Message string `json:"message"`
}

// Union type for all possible responses
type SetScreenResolutionResponseObject interface {
	SetScreenResolutionResponse()
}

// Implement response interface for each response type
func (SetScreenResolution200JSONResponse) SetScreenResolutionResponse() {}
func (SetScreenResolution400JSONResponse) SetScreenResolutionResponse() {}
func (SetScreenResolution409JSONResponse) SetScreenResolutionResponse() {}
func (SetScreenResolution500JSONResponse) SetScreenResolutionResponse() {}

func (s *ApiService) SetScreenResolution(ctx context.Context, request SetScreenResolutionRequestObject) (SetScreenResolutionResponseObject, error) {
	log := logger.FromContext(ctx)

	// Validate parameters
	width := request.Width
	height := request.Height
	rate := request.Rate

	// Parameters were already validated in OpenAPI spec, but we'll do a sanity check here
	if width < 200 || width > 8000 {
		return SetScreenResolution400JSONResponse{
			Message: fmt.Sprintf("width must be between 200 and 8000, got %d", width),
		}, nil
	}

	if height < 200 || height > 8000 {
		return SetScreenResolution400JSONResponse{
			Message: fmt.Sprintf("height must be between 200 and 8000, got %d", height),
		}, nil
	}

	if rate != nil && (*rate < 24 || *rate > 240) {
		return SetScreenResolution400JSONResponse{
			Message: fmt.Sprintf("rate must be between 24 and 240, got %d", *rate),
		}, nil
	}

	// Check if ffmpeg is running (indicating an active recording)
	cmd := exec.Command("pgrep", "ffmpeg")
	if err := cmd.Run(); err == nil {
		// ffmpeg is running
		return SetScreenResolution409JSONResponse{
			Message: "detected ongoing replay recording process, close the recording first before switching resolution",
		}, nil
	}

	// Get the WebSocket URL from the request or use default
	wsURL := request.WSURL
	// Fallback to default local URL if not provided
	if wsURL == "" {
		wsURL = "ws://localhost:8080/ws?password=admin&username=kernel"
	}

	log.Info("using websocket URL", "url", wsURL)

	dialer := websocket.Dialer{
		HandshakeTimeout: 5 * time.Second,
	}

	conn, _, err := dialer.Dial(wsURL, nil)
	if err != nil {
		log.Error("failed to connect to websocket", "err", err)
		return SetScreenResolution500JSONResponse{
			Message: "failed to connect to websocket server",
		}, nil
	}
	defer conn.Close()

	// Prepare message
	message := map[string]interface{}{
		"event":  "screen/set",
		"width":  width,
		"height": height,
	}

	// Add rate if provided
	if rate != nil {
		message["rate"] = *rate
	}

	// Serialize message to JSON
	messageJSON, err := json.Marshal(message)
	if err != nil {
		log.Error("failed to marshal JSON message", "err", err)
		return SetScreenResolution500JSONResponse{
			Message: "failed to prepare websocket message",
		}, nil
	}

	// Send message
	if err := conn.WriteMessage(websocket.TextMessage, messageJSON); err != nil {
		log.Error("failed to send websocket message", "err", err)
		return SetScreenResolution500JSONResponse{
			Message: "failed to send command to websocket server",
		}, nil
	}

	// Wait for response (optional, but might be good to ensure it worked)
	conn.SetReadDeadline(time.Now().Add(5 * time.Second))
	_, response, err := conn.ReadMessage()
	if err != nil {
		log.Warn("did not receive websocket response, but proceeding", "err", err)
		// Continue anyway since we don't know if the server responds
	} else {
		log.Info("received websocket response", "response", string(response))
	}

	return SetScreenResolution200JSONResponse{
		Ok: true,
	}, nil
}

func (s *ApiService) ClickMouse(ctx context.Context, request oapi.ClickMouseRequestObject) (oapi.ClickMouseResponseObject, error) {
	log := logger.FromContext(ctx)

	// Validate request body
	if request.Body == nil {
		return oapi.ClickMouse400JSONResponse{BadRequestErrorJSONResponse: oapi.BadRequestErrorJSONResponse{Message: "request body is required"}}, nil
	}
	body := *request.Body

	// Ensure non-negative coordinates
	if body.X < 0 || body.Y < 0 {
		return oapi.ClickMouse400JSONResponse{BadRequestErrorJSONResponse: oapi.BadRequestErrorJSONResponse{Message: "coordinates must be non-negative"}}, nil
	}

	// Map button enum to xdotool button code. Default to left button.
	btn := "1"
	if body.Button != nil {
		buttonMap := map[oapi.ClickMouseRequestButton]string{
			oapi.Left:    "1",
			oapi.Middle:  "2",
			oapi.Right:   "3",
			oapi.Back:    "8",
			oapi.Forward: "9",
		}
		var ok bool
		btn, ok = buttonMap[*body.Button]
		if !ok {
			return oapi.ClickMouse400JSONResponse{BadRequestErrorJSONResponse: oapi.BadRequestErrorJSONResponse{Message: fmt.Sprintf("unsupported button: %s", *body.Button)}}, nil
		}
	}

	// Determine number of clicks (defaults to 1)
	numClicks := 1
	if body.NumClicks != nil && *body.NumClicks > 0 {
		numClicks = *body.NumClicks
	}

	// Build xdotool arguments
	args := []string{}

	// Hold modifier keys (keydown)
	if body.HoldKeys != nil {
		for _, key := range *body.HoldKeys {
			args = append(args, "keydown", key)
		}
	}

	// Move the cursor
	args = append(args, "mousemove", "--sync", strconv.Itoa(body.X), strconv.Itoa(body.Y))

	// click type defaults to click
	clickType := oapi.Click
	if body.ClickType != nil {
		clickType = *body.ClickType
	}

	// Perform the click action
	switch clickType {
	case oapi.Down:
		args = append(args, "mousedown", btn)
	case oapi.Up:
		args = append(args, "mouseup", btn)
	case oapi.Click:
		args = append(args, "click")
		if numClicks > 1 {
			args = append(args, "--repeat", strconv.Itoa(numClicks))
		}
		args = append(args, btn)
	default:
		return oapi.ClickMouse400JSONResponse{BadRequestErrorJSONResponse: oapi.BadRequestErrorJSONResponse{Message: fmt.Sprintf("unsupported click type: %s", clickType)}}, nil
	}

	// Release modifier keys (keyup)
	if body.HoldKeys != nil {
		for _, key := range *body.HoldKeys {
			args = append(args, "keyup", key)
		}
	}

	log.Info("executing xdotool", "args", args)

	output, err := defaultXdoTool.Run(ctx, args...)
	if err != nil {
		log.Error("xdotool command failed", "err", err, "output", string(output))
		return oapi.ClickMouse500JSONResponse{InternalErrorJSONResponse: oapi.InternalErrorJSONResponse{Message: "failed to execute mouse action"}}, nil
	}

	return oapi.ClickMouse200Response{}, nil
}
