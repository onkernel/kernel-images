package api

import (
	"context"
	"encoding/json"
	"fmt"
	"net/url"
	"os/exec"
	"strconv"
	"strings"
	"time"

	"github.com/gorilla/websocket"
	"github.com/onkernel/kernel-images/server/lib/logger"
	oapi "github.com/onkernel/kernel-images/server/lib/oapi"
)

func (s *ApiService) MoveMouse(ctx context.Context, request oapi.MoveMouseRequestObject) (oapi.MoveMouseResponseObject, error) {
	log := logger.FromContext(ctx)

	// Validate request body
	if request.Body == nil {
		return oapi.MoveMouse400JSONResponse{BadRequestErrorJSONResponse: oapi.BadRequestErrorJSONResponse{Message: "request body is required"}}, nil
	}
	body := *request.Body

	// Ensure non-negative coordinates
	if body.X < 0 || body.Y < 0 {
		return oapi.MoveMouse400JSONResponse{BadRequestErrorJSONResponse: oapi.BadRequestErrorJSONResponse{Message: "coordinates must be non-negative"}}, nil
	}

	// Build xdotool arguments
	args := []string{}

	// Hold modifier keys (keydown)
	if body.HoldKeys != nil {
		for _, key := range *body.HoldKeys {
			args = append(args, "keydown", key)
		}
	}

	// Move the cursor to the desired coordinates
	args = append(args, "mousemove", "--sync", strconv.Itoa(body.X), strconv.Itoa(body.Y))

	// Release modifier keys (keyup)
	if body.HoldKeys != nil {
		for _, key := range *body.HoldKeys {
			args = append(args, "keyup", key)
		}
	}

	log.Info("executing xdotool", "args", args)

	output, err := defaultXdoTool.Run(ctx, args...)
	if err != nil {
		log.Error("xdotool command failed", "err", err, "output", string(output))
		return oapi.MoveMouse500JSONResponse{InternalErrorJSONResponse: oapi.InternalErrorJSONResponse{Message: "failed to move mouse"}}, nil
	}

	return oapi.MoveMouse200Response{}, nil
}

// Define interface types for our new endpoint
// These should match the structure expected by the generated code

// SetScreenResolutionParams represents query parameters for our endpoint
type SetScreenResolutionParams struct {
	Width  int
	Height int
	Rate   *int
}

// For testing
type SetScreenResolutionFunc func(ctx context.Context, req SetScreenResolutionRequestObject) (SetScreenResolutionResponseObject, error)

// This would be auto-generated by oapi-codegen, but we're defining it manually
type SetScreenResolutionRequestObject struct {
	Width  int    // Required query parameter
	Height int    // Required query parameter
	Rate   *int   // Optional query parameter
	WSURL  string // WebSocket URL (calculated in handler)
}

// Response types for different status codes
type SetScreenResolution200JSONResponse struct {
	Ok bool `json:"ok"`
}

type SetScreenResolution400JSONResponse struct {
	Message string `json:"message"`
}

type SetScreenResolution409JSONResponse struct {
	Message string `json:"message"`
}

type SetScreenResolution500JSONResponse struct {
	Message string `json:"message"`
}

// Union type for all possible responses
type SetScreenResolutionResponseObject interface {
	SetScreenResolutionResponse()
}

// Implement response interface for each response type
func (SetScreenResolution200JSONResponse) SetScreenResolutionResponse() {}
func (SetScreenResolution400JSONResponse) SetScreenResolutionResponse() {}
func (SetScreenResolution409JSONResponse) SetScreenResolutionResponse() {}
func (SetScreenResolution500JSONResponse) SetScreenResolutionResponse() {}

func (s *ApiService) SetScreenResolution(ctx context.Context, request SetScreenResolutionRequestObject) (SetScreenResolutionResponseObject, error) {
	log := logger.FromContext(ctx)

	// Validate parameters
	width := request.Width
	height := request.Height
	rate := request.Rate

	// Parameters were already validated in OpenAPI spec, but we'll do a sanity check here
	if width < 200 || width > 8000 {
		return SetScreenResolution400JSONResponse{
			Message: fmt.Sprintf("width must be between 200 and 8000, got %d", width),
		}, nil
	}

	if height < 200 || height > 8000 {
		return SetScreenResolution400JSONResponse{
			Message: fmt.Sprintf("height must be between 200 and 8000, got %d", height),
		}, nil
	}

	if rate != nil && (*rate < 24 || *rate > 240) {
		return SetScreenResolution400JSONResponse{
			Message: fmt.Sprintf("rate must be between 24 and 240, got %d", *rate),
		}, nil
	}

	// Check if ffmpeg is running (indicating an active recording)
	cmd := exec.Command("pgrep", "ffmpeg")
	if err := cmd.Run(); err == nil {
		// ffmpeg is running
		return SetScreenResolution409JSONResponse{
			Message: "detected ongoing replay recording process, close the recording first before switching resolution",
		}, nil
	}

	// Get the WebSocket URL from the request
	wsURL := request.WSURL

	// Prepare multiple fallback URLs for different environments
	fallbackURLs := []string{
		// Internal container URL (direct to the WS service)
		"ws://127.0.0.1:8080/ws?password=admin&username=kernel",
		// Docker service name URL (for container networking)
		"ws://browser:8080/ws?password=admin&username=kernel",
		// Local development fallback
		"ws://localhost:8080/ws?password=admin&username=kernel",
	}

	// Check if it's a host-based URL from production
	isProduction := !strings.Contains(wsURL, "localhost") && !strings.Contains(wsURL, "127.0.0.1")

	// For production URLs, ensure we're using the format from the Vue client logs
	if isProduction {
		// Parse and fix the URL if needed
		if parsedURL, err := url.Parse(wsURL); err == nil {
			// Remove port from host if present
			host := parsedURL.Host
			if hostParts := strings.Split(host, ":"); len(hostParts) > 1 {
				parsedURL.Host = hostParts[0]
				// Update the wsURL without the port
				wsURL = parsedURL.String()
				log.Info("fixed production WebSocket URL by removing port", "url", wsURL)
			}
		}
	}

	// Try all possible URLs
	var conn *websocket.Conn
	var dialErr error

	// Create a dialer with appropriate timeouts
	dialer := websocket.Dialer{
		HandshakeTimeout: 3 * time.Second,
	}

	// First try the primary URL
	log.Info("trying primary websocket URL", "url", wsURL)
	conn, _, dialErr = dialer.Dial(wsURL, nil)

	// If successful, use this connection
	if dialErr == nil {
		log.Info("successfully connected to primary WebSocket URL", "url", wsURL)
	} else {
		log.Warn("primary websocket URL failed", "url", wsURL, "err", dialErr)

		// Try each fallback URL
		for _, fallbackURL := range fallbackURLs {
			// Don't retry the same URL
			if fallbackURL == wsURL {
				continue
			}

			log.Info("trying fallback websocket URL", "url", fallbackURL)
			conn, _, dialErr = dialer.Dial(fallbackURL, nil)

			if dialErr == nil {
				log.Info("successfully connected to fallback WebSocket URL", "url", fallbackURL)
				break
			} else {
				log.Warn("fallback websocket URL failed", "url", fallbackURL, "err", dialErr)
			}
		}

		// If all attempts failed
		if dialErr != nil {
			log.Error("all websocket connection attempts failed")
			return SetScreenResolution500JSONResponse{
				Message: "failed to connect to websocket server after multiple attempts",
			}, nil
		}
	}

	// Ensure connection is closed when we're done, like wscat -c '...' -x '...' would do
	defer func() {
		log.Info("closing websocket connection")
		// Send close message for clean shutdown
		closeMsg := websocket.FormatCloseMessage(websocket.CloseNormalClosure, "")
		err := conn.WriteControl(websocket.CloseMessage, closeMsg, time.Now().Add(time.Second))
		if err != nil {
			log.Warn("failed to send close message", "err", err)
		}
		conn.Close()
	}()

	log.Info("successfully connected to websocket", "url", wsURL)

	// Prepare message
	message := map[string]interface{}{
		"event":  "screen/set",
		"width":  width,
		"height": height,
	}

	// Add rate if provided
	if rate != nil {
		message["rate"] = *rate
	}

	// Serialize message to JSON
	messageJSON, err := json.Marshal(message)
	if err != nil {
		log.Error("failed to marshal JSON message", "err", err)
		return SetScreenResolution500JSONResponse{
			Message: "failed to prepare websocket message",
		}, nil
	}

	// Send message
	if err := conn.WriteMessage(websocket.TextMessage, messageJSON); err != nil {
		log.Error("failed to send websocket message", "err", err)
		return SetScreenResolution500JSONResponse{
			Message: "failed to send command to websocket server",
		}, nil
	}

	// Wait for response with short timeout
	conn.SetReadDeadline(time.Now().Add(1 * time.Second))
	_, response, err := conn.ReadMessage()
	if err != nil {
		log.Warn("did not receive websocket response, but proceeding", "err", err)
		// Continue anyway since we don't know if the server responds
	} else {
		log.Info("received websocket response", "response", string(response))
	}

	return SetScreenResolution200JSONResponse{
		Ok: true,
	}, nil
}

func (s *ApiService) ClickMouse(ctx context.Context, request oapi.ClickMouseRequestObject) (oapi.ClickMouseResponseObject, error) {
	log := logger.FromContext(ctx)

	// Validate request body
	if request.Body == nil {
		return oapi.ClickMouse400JSONResponse{BadRequestErrorJSONResponse: oapi.BadRequestErrorJSONResponse{Message: "request body is required"}}, nil
	}
	body := *request.Body

	// Ensure non-negative coordinates
	if body.X < 0 || body.Y < 0 {
		return oapi.ClickMouse400JSONResponse{BadRequestErrorJSONResponse: oapi.BadRequestErrorJSONResponse{Message: "coordinates must be non-negative"}}, nil
	}

	// Map button enum to xdotool button code. Default to left button.
	btn := "1"
	if body.Button != nil {
		buttonMap := map[oapi.ClickMouseRequestButton]string{
			oapi.Left:    "1",
			oapi.Middle:  "2",
			oapi.Right:   "3",
			oapi.Back:    "8",
			oapi.Forward: "9",
		}
		var ok bool
		btn, ok = buttonMap[*body.Button]
		if !ok {
			return oapi.ClickMouse400JSONResponse{BadRequestErrorJSONResponse: oapi.BadRequestErrorJSONResponse{Message: fmt.Sprintf("unsupported button: %s", *body.Button)}}, nil
		}
	}

	// Determine number of clicks (defaults to 1)
	numClicks := 1
	if body.NumClicks != nil && *body.NumClicks > 0 {
		numClicks = *body.NumClicks
	}

	// Build xdotool arguments
	args := []string{}

	// Hold modifier keys (keydown)
	if body.HoldKeys != nil {
		for _, key := range *body.HoldKeys {
			args = append(args, "keydown", key)
		}
	}

	// Move the cursor
	args = append(args, "mousemove", "--sync", strconv.Itoa(body.X), strconv.Itoa(body.Y))

	// click type defaults to click
	clickType := oapi.Click
	if body.ClickType != nil {
		clickType = *body.ClickType
	}

	// Perform the click action
	switch clickType {
	case oapi.Down:
		args = append(args, "mousedown", btn)
	case oapi.Up:
		args = append(args, "mouseup", btn)
	case oapi.Click:
		args = append(args, "click")
		if numClicks > 1 {
			args = append(args, "--repeat", strconv.Itoa(numClicks))
		}
		args = append(args, btn)
	default:
		return oapi.ClickMouse400JSONResponse{BadRequestErrorJSONResponse: oapi.BadRequestErrorJSONResponse{Message: fmt.Sprintf("unsupported click type: %s", clickType)}}, nil
	}

	// Release modifier keys (keyup)
	if body.HoldKeys != nil {
		for _, key := range *body.HoldKeys {
			args = append(args, "keyup", key)
		}
	}

	log.Info("executing xdotool", "args", args)

	output, err := defaultXdoTool.Run(ctx, args...)
	if err != nil {
		log.Error("xdotool command failed", "err", err, "output", string(output))
		return oapi.ClickMouse500JSONResponse{InternalErrorJSONResponse: oapi.InternalErrorJSONResponse{Message: "failed to execute mouse action"}}, nil
	}

	return oapi.ClickMouse200Response{}, nil
}
